<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>配置vim作为IDE</title>
      <link href="/2018-08-02/%E9%85%8D%E7%BD%AEvim%E4%BD%9C%E4%B8%BAIDE/"/>
      <url>/2018-08-02/%E9%85%8D%E7%BD%AEvim%E4%BD%9C%E4%B8%BAIDE/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>vim 是世界上最强大的编辑器</p><h2 id="安装Vundle"><a href="#安装Vundle" class="headerlink" title="安装Vundle"></a>安装Vundle</h2><p><code>git clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim</code></p><h2 id="配置～-vimrc"><a href="#配置～-vimrc" class="headerlink" title="配置～/.vimrc"></a>配置～/.vimrc</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible              <span class="string">" required</span></span><br><span class="line"><span class="string">filetype off                  "</span> required</span><br><span class="line"></span><br><span class="line"><span class="string">" set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="string">set rtp+=~/.vim/bundle/Vundle.vim</span></span><br><span class="line"><span class="string">call vundle#begin()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> alternatively, <span class="keyword">pass</span> a path where Vundle should install plugins</span><br><span class="line"><span class="string">"call vundle#begin('~/some/path/here')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> let Vundle manage Vundle, required</span><br><span class="line">Plugin <span class="string">'gmarik/Vundle.vim'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" Add all your plugins here (note older versions of Vundle used Bundle instead of Plugin)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> All of your Plugins must be added before the following line</span><br><span class="line">call vundle<span class="comment">#end()            " required</span></span><br><span class="line">filetype plugin indent on    <span class="string">" required</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Enable folding</span><br><span class="line">set foldmethod=indent</span><br><span class="line">set foldlevel=<span class="number">99</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'tmhedberg/SimpylFold'</span></span><br><span class="line"></span><br><span class="line"><span class="string">" Enable folding with the spacebar</span></span><br><span class="line"><span class="string">nnoremap &lt;space&gt; za</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set splitbelow</span></span><br><span class="line"><span class="string">set splitright</span></span><br><span class="line"><span class="string">"</span>split navigations</span><br><span class="line">nnoremap &lt;C-J&gt; &lt;C-W&gt;&lt;C-J&gt;</span><br><span class="line">nnoremap &lt;C-K&gt; &lt;C-W&gt;&lt;C-K&gt;</span><br><span class="line">nnoremap &lt;C-L&gt; &lt;C-W&gt;&lt;C-L&gt;</span><br><span class="line">nnoremap &lt;C-H&gt; &lt;C-W&gt;&lt;C-H&gt;</span><br><span class="line"></span><br><span class="line">au BufNewFile,BufRead *.py</span><br><span class="line">    \ set tabstop=<span class="number">4</span> |</span><br><span class="line">    \ set softtabstop=<span class="number">4</span> |</span><br><span class="line">    \ set shiftwidth=<span class="number">4</span> |</span><br><span class="line">    \ set textwidth=<span class="number">79</span> |</span><br><span class="line">    \ set expandtab |</span><br><span class="line">    \ set autoindent |</span><br><span class="line">    \ set fileformat=unix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">au BufNewFile,BufRead *.js,*.html,*.css</span><br><span class="line">    \ set tabstop=<span class="number">2</span> |</span><br><span class="line">    \ set softtabstop=<span class="number">2</span> |</span><br><span class="line">    \ set shiftwidth=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'vim-scripts/indentpython.vim'</span></span><br><span class="line"></span><br><span class="line">Bundle <span class="string">'Valloric/YouCompleteMe'</span></span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion=<span class="number">1</span></span><br><span class="line">map &lt;leader&gt;g  :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">"Flagging Unnecessary Whitespace</span></span><br><span class="line"><span class="string">highlight BadWhitespace ctermbg=red guibg=darkred</span></span><br><span class="line"><span class="string">au BufRead,BufNewFile *.py,*.pyw,*.c,*.h match BadWhitespace /\s\+$/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set encoding=utf-8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span>python <span class="keyword">with</span> virtualenv support</span><br><span class="line">py &lt;&lt; EOF</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> <span class="string">'VIRTUAL_ENV'</span> <span class="keyword">in</span> os.environ:</span><br><span class="line">  project_base_dir = os.environ[<span class="string">'VIRTUAL_ENV'</span>]</span><br><span class="line">  activate_this = os.path.join(project_base_dir, <span class="string">'bin/activate_this.py'</span>)</span><br><span class="line">  execfile(activate_this, dict(__file__=activate_this))</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'scrooloose/syntastic'</span></span><br><span class="line">Plugin <span class="string">'nvie/vim-flake8'</span></span><br><span class="line">let python_highlight_all=<span class="number">1</span></span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'jnurmine/Zenburn'</span></span><br><span class="line">Plugin <span class="string">'altercation/vim-colors-solarized'</span></span><br><span class="line"><span class="keyword">if</span> has(<span class="string">'gui_running'</span>)</span><br><span class="line">  set background=dark</span><br><span class="line">  colorscheme solarized</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  colorscheme zenburn</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">call togglebg<span class="comment">#map("&lt;F5&gt;")</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'scrooloose/nerdtree'</span></span><br><span class="line"></span><br><span class="line">Plugin <span class="string">'jistr/vim-nerdtree-tabs'</span></span><br><span class="line"></span><br><span class="line">let NERDTreeIgnore=[<span class="string">'\.pyc$'</span>, <span class="string">'\~$'</span>] <span class="string">"ignore files in NERDTree</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plugin 'kien/ctrlp.vim'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set nu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plugin 'tpope/vim-fugitive'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Plugin 'Lokaltog/powerline', &#123;'rtp': 'powerline/bindings/vim/'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set clipboard=unnamed</span></span><br></pre></td></tr></table></figure><h2 id="用Vundle-安装-vimrc中的插件"><a href="#用Vundle-安装-vimrc中的插件" class="headerlink" title="用Vundle 安装.vimrc中的插件"></a>用Vundle 安装.vimrc中的插件</h2><ol><li>打开vim输入<code>:PluginInstall</code>，安装完大部分插件除了YouCompleteMe</li><li>brew install cmake，（没brew的自己下）</li><li>进入~/.vim/bundle/YouCompleteMe，执行./intall.sh</li><li>配置vim完毕</li></ol>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>那个关于+=的问题的再次解释</title>
      <link href="/2018-05-13/%E9%82%A3%E4%B8%AA%E5%85%B3%E4%BA%8E+=%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%8D%E6%AC%A1%E8%A7%A3%E9%87%8A/"/>
      <url>/2018-05-13/%E9%82%A3%E4%B8%AA%E5%85%B3%E4%BA%8E+=%E7%9A%84%E9%97%AE%E9%A2%98%E7%9A%84%E5%86%8D%E6%AC%A1%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>读了《流畅的python》一书后，对<a href="https://hungfoolishry.github.io/2017-12-17/python%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E5%B0%8F%E5%B0%8F%E9%97%AE%E9%A2%98/#more" title="python中的几个小小小问题">python中的几个小小小问题</a>“元组a_tuple[i] += [‘item’] 虽然报错但是却生效了”中的问题进行再次解释。</p><p>##正文<br>推荐一个python代码可视化网站:<a href="http://www.pythontutor.com/" target="_blank" rel="noopener">http://www.pythontutor.com/</a></p><p>书中对<code>s[a] += b</code>字节码进行了解释，然后问题就变得更加清楚。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dis.dis(&apos;s[a] += b&apos;)</span><br><span class="line">1                 0 LOAD_NAME                   0(s)</span><br><span class="line">                   3 LOAD_NAME                   1(a)</span><br><span class="line">                   6 DUP_TOP_TWO</span><br><span class="line">                   7 BINARY_SUBSCR</span><br><span class="line">                   8 LOAD_NAME                     2(b)</span><br><span class="line">                   11 INPLACE_ADD</span><br><span class="line">                   12 ROT_THREE</span><br><span class="line">                   13 STORE_SUBSCR</span><br><span class="line">                   14 LOAD_CONST                  0(None)</span><br><span class="line">                   17 RETURN_VALUE</span><br></pre></td></tr></table></figure></p><ul><li>11 进行<code>+=b</code>操作，也就是列表追加，列表可变，那么可以完成</li><li>13 进行<code>s[a]</code>赋值操作，发现元组不可变，赋值失败。此时列表存的东西变了。</li></ul><p>其实可以这么理解，元组只是知道列表的位置，列表存什么是不知道的。然后列表还是那个列表，但是存的内容却不是那个内容了。通俗点讲，你（元组），你大爷（列表地址）还是你大爷，但是你大妈（列表内容）已经不是你大妈了。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ol><li>流畅的Python [巴西] Luciano Ramalho (作者) 安道 , 吴珂 (译者)</li></ol>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>流畅的python小记01</title>
      <link href="/2018-04-11/%E6%B5%81%E7%95%85%E7%9A%84python%E5%B0%8F%E8%AE%B001/"/>
      <url>/2018-04-11/%E6%B5%81%E7%95%85%E7%9A%84python%E5%B0%8F%E8%AE%B001/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>  好久没写blog，一来清明节回家没带电脑，二来最近搬家没网，三来。。。好吧，好吧，就是懒，懒。机缘巧合在别人那里听闻有一本书叫流畅的python。python慢是我之前学习印象，GIL锁导致无法高效实用多线程，只能用多进程跑多核，多进程又占用资源过大，所以大多数需要效率的代码都是用java或者其他语言，类似Go语言写的。(是不是应该学学Go？)既然入了python的坑，那么再挖挖吧，说不定还能挖点啥出来，比如人工智能啥的。</p><h2 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h2><p>之前说过，类似这样的<code>__len__</code>    的方法是python的内置方法，解释器在调用的时候会进行隐式调用。<br>比如<code>len(my_list)</code>会隐式调用<code>my_list.__len__()</code>。<code>for i in x</code> 会隐式调用<code>x.__iter__()</code>。<br>tips： <code>len</code>不是一个普通方法，如果是一个内置类型， 比如list，set， 那么<code>len</code>这个方法会直接从底层的C结构体中读取该内置类型的长度，不调用方法。所以无论该内置类型有多少元素，<code>len</code>的计算速度是一个常数。<br><a href="https://docs.python.org/3/reference/datamodel.html" title="官方列出的python3特殊方法" target="_blank" rel="noopener">官方列出的python3数据模型</a></p><h2 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h2><p>在python2中如下代码中x会被替换为C,但是在python3中该问题不会出现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">'my precious'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dummy = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'ABC'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x </span><br><span class="line"><span class="string">'C'</span></span><br></pre></td></tr></table></figure></p><p>filter与map能做的，列表推导也能做，并且不一定谁比谁快<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line">TIMES = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">SETUP = <span class="string">"""</span></span><br><span class="line"><span class="string">symbols = '$¢£¥€¤'</span></span><br><span class="line"><span class="string">def non_ascii(c):</span></span><br><span class="line"><span class="string">    return c &gt; 127</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(label, cmd)</span>:</span></span><br><span class="line">    res = timeit.repeat(cmd, setup=SETUP, number=TIMES)</span><br><span class="line">    print(label, *(<span class="string">'&#123;:.3f&#125;'</span>.format(x) <span class="keyword">for</span> x <span class="keyword">in</span> res))</span><br><span class="line"></span><br><span class="line">clock(<span class="string">'listcomp        :'</span>, <span class="string">'[ord(s) for s in symbols if ord(s) &gt; 127]'</span>)</span><br><span class="line">clock(<span class="string">'listcomp + func :'</span>, <span class="string">'[ord(s) for s in symbols if non_ascii(ord(s))]'</span>)</span><br><span class="line">clock(<span class="string">'filter + lambda :'</span>, <span class="string">'list(filter(lambda c: c &gt; 127, map(ord, symbols)))'</span>)</span><br><span class="line">clock(<span class="string">'filter + func   :'</span>, <span class="string">'list(filter(non_ascii, map(ord, symbols)))'</span>)</span><br></pre></td></tr></table></figure></p><p>用菜鸟网站的python3 在线运行的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listcomp        : 0.021 0.022 0.020</span><br><span class="line">listcomp + func : 0.032 0.032 0.031</span><br><span class="line">filter + lambda : 0.029 0.030 0.028</span><br><span class="line">filter + func   : 0.026 0.026 0.029</span><br></pre></td></tr></table></figure></p><h2 id="元组是对数据的记录包括数据的位置"><a href="#元组是对数据的记录包括数据的位置" class="headerlink" title="元组是对数据的记录包括数据的位置"></a>元组是对数据的记录包括数据的位置</h2><p>python3 中，可以进行如下平行赋值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b *rest = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b , rest</span><br><span class="line">(<span class="number">0</span>,<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] )</span><br></pre></td></tr></table></figure></p><p>当然可以把<code>*</code>放在中间，前后有变量也可以，比如<code>a, b *rest, c = range(5)</code></p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p> 为什么切片和区间会忽略最后一个元素？原文如下解释，深解我惑。</p><ul><li>当只有最后一个位置信息时， 我们也可以快速看出切片和区间里有几个元素：<code>range(3)</code>和 <code>my_list[:3]</code> 都返回 3 个元素。</li><li>当起止位置信息都可见时， 我们可以快速计算出切片和区间的长度， 用后一个数减去第一个下标（stop - start） 即可。</li><li>这样做也让我们可以利用任意一个下标来把序列分割成不重叠的两部分， 只要写成<code>my_list[:x]</code> 和 <code>my_list[x:]</code>就可以了。</li></ul><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ol><li>流畅的Python [巴西] Luciano Ramalho (作者) 安道 , 吴珂 (译者)    </li></ol>]]></content>
      
      <categories>
          
          <category> 小读小想小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>入门学习tornado</title>
      <link href="/2018-03-25/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0tornado/"/>
      <url>/2018-03-25/%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0tornado/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>原来用的Python框架是django，也都是界面的人去做，也只写过一些简单的html 还有 js代码，一些view代码。OpenStack只是把django作为一个页面展示，通过restful接口去调用后端的实现。后面要用tornado框架了，还不得好好恶补下。还有redis，postgreSQl。。。</p><h2 id="tornado："><a href="#tornado：" class="headerlink" title="tornado："></a>tornado：</h2><p>tornado给我留下的几个关键字就是，异步、协程、高并发。看完5篇写得还可以的文章<sup>[1]</sup>，总体要对tornado框架要有如下图的见解。<br><a href="https://images0.cnblogs.com/blog2015/425762/201506/211916272795074.png" title="tornado 框架" target="_blank" rel="noopener"><img src="https://images0.cnblogs.com/blog2015/425762/201506/211916272795074.png" alt="tornado 框架" title="tornado 框架"></a></p><p>上图整个过程可以分为两大部分：</p><h3 id="1-启动程序阶段，又称为待请求阶段（上图1、2所有系列和3-0）"><a href="#1-启动程序阶段，又称为待请求阶段（上图1、2所有系列和3-0）" class="headerlink" title="1.  启动程序阶段，又称为待请求阶段（上图1、2所有系列和3.0）"></a>1.  启动程序阶段，又称为待请求阶段（上图1、2所有系列和3.0）</h3><ul><li>url映射: <code>Application.__init__</code></li><li>每个url通过正则匹配获取对应的handler：<code>Application.add_handlers</code></li><li>建立HTTPServer进行监听请求：<code>application.listen(xxx)</code>。其中用到的IOLoop,epoll还需要进一步研究</li><li>死循环开始监听请求:<code>tornado.ioloop.IOLoop.instance().start()</code></li></ul><h3 id="2-接收并处理客户端请求阶段（上图3系列）"><a href="#2-接收并处理客户端请求阶段（上图3系列）" class="headerlink" title="2. 接收并处理客户端请求阶段（上图3系列）"></a>2. 接收并处理客户端请求阶段（上图3系列）</h3><p>个人理解，就是分三部分：1，处理请求。2，将信息传递给handler。3，handler处理完后返回相应请求。<br>博客中提及的大概就是如下（个人猜测少了请求后的清理流程）：<br>对于整个3系列按照功能可以划分为四大部分：</p><ul><li>获取用户请求数据（上图3.4）</li><li>根据用户请求URL进行路由匹配，从而使得某个方法处理具体的请求（上图3.5～3.19）</li><li>将处理后的数据返回给客户端（上图3.21～3.23）</li><li>关闭客户端socket（上图3.24～3.26）</li></ul><h3 id="3-页面渲染"><a href="#3-页面渲染" class="headerlink" title="3.页面渲染"></a>3.页面渲染</h3><p>将数据根据规则写入template，返回给用户浏览器，得以页面呈现。好吧，这里还没看。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ol><li><a href="http://www.cnblogs.com/wupeiqi/tag/Tornado/" title="武沛齐博客中几篇tornado的文章" target="_blank" rel="noopener">武沛齐博客中几篇tornado的文章</a></li><li><a href="http://www.tornadoweb.org/en/stable/" title="tornado官网" target="_blank" rel="noopener">tornado官网</a></li></ol>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tornado </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>百度云苏州虚拟机测试</title>
      <link href="/2018-03-18/%E7%99%BE%E5%BA%A6%E4%BA%91%E8%8B%8F%E5%B7%9E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B5%8B%E8%AF%95/"/>
      <url>/2018-03-18/%E7%99%BE%E5%BA%A6%E4%BA%91%E8%8B%8F%E5%B7%9E%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>vultr 的主机IP一直被封封，用express吧。不折腾。<br>虚拟机是要有个的，百度最近九块九一个月虚拟机体验，拿来玩玩。</p><h2 id="正文："><a href="#正文：" class="headerlink" title="正文："></a>正文：</h2><h3 id="Instance："><a href="#Instance：" class="headerlink" title="Instance："></a>Instance：</h3><table><thead><tr><th>地区</th><th>cpu</th><th>内存</th><th>带宽</th><th>磁盘</th></tr></thead><tbody><tr><td>苏州</td><td>1核</td><td>1GB</td><td>1M</td><td>40GB</td></tr></tbody></table><h3 id="Ping-测试："><a href="#Ping-测试：" class="headerlink" title="Ping 测试："></a>Ping 测试：</h3><p>正在 Ping 106.12.xxx.xxx 具有 32 字节的数据:<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=12ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=13ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=36ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=9ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=37ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=12ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=8ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=10ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=8ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=39ms TTL=54<br>请求超时。<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=33ms TTL=54<br>请求超时。<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=9ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=99ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=11ms TTL=54<br>请求超时。<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=33ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=12ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=25ms TTL=54<br>请求超时。<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=71ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=10ms TTL=54<br>来自 106.12.xxx.xxx 的回复: 字节=32 时间=14ms TTL=54</p><p>106.12.xxx.xxx 的 Ping 统计信息:<br>    数据包: 已发送 = 24，已接收 = 20，丢失 = 4 (16% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 8ms，最长 = 99ms，平均 = 25ms</p><h3 id="cpu："><a href="#cpu：" class="headerlink" title="cpu："></a>cpu：</h3><p>========================================================================<br>   BYTE UNIX Benchmarks (Version 5.1.3)</p><p>   System: instance-3fc37oek: GNU/Linux<br>   OS: GNU/Linux – 3.10.0-693.11.1.el7.x86_64 – #1 SMP Mon Dec 4 23:52:40 UTC 2017<br>   Machine: x86_64 (x86_64)<br>   Language: en_US.utf8 (charmap=”UTF-8”, collate=”UTF-8”)<br>   CPU 0: Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz (4788.9 bogomips)<br>          x86-64, MMX, Physical Address Ext, SYSENTER/SYSEXIT, SYSCALL/SYSRET<br>   14:00:17 up 15 min,  1 user,  load average: 0.36, 0.09, 0.05; runlevel 3</p><hr><p>Benchmark Run: Sun Mar 18 2018 14:00:17 - 14:28:20<br>1 CPU in system; running 1 parallel copy of tests</p><p><strong>Dhrystone 2 using register variables       28291179.7 lps   (10.0 s, 7 samples)</strong></p><blockquote><p>Dhrystone 2 using register variables<br>此项用于测试 string handling，因为没有浮点操作，所以深受软件和硬件设计（hardware and software design）、编译和链接（compiler and linker options）、代码优化（code optimazaton）、对内存的cache（cache memory）、等待状态（wait states）、整数数据类型（integer data types）的影响。</p></blockquote><p><strong>Double-Precision Whetstone                     4275.6 MWIPS (9.7 s, 7 samples)</strong></p><blockquote><p>Double-Precision Whetstone<br>这一项测试浮点数操作的速度和效率。这一测试包括几个模块，每个模块都包括一组用于科学计算的操作。覆盖面很广的一系列 c 函数：sin，cos，sqrt，exp，log 被用于整数和浮点数的数学运算、数组访问、条件分支（conditional branch）和程序调用。此测试同时测试了整数和浮点数算术运算。</p></blockquote><p><strong>Execl Throughput                               3557.4 lps   (30.0 s, 2 samples)</strong></p><blockquote><p>Execl Throughput<br>此测试考察每秒钟可以执行的 execl 系统调用的次数。 execl 系统调用是 exec 函数族的一员。它和其他一些与之相似的命令一样是 execve（） 函数的前端。</p></blockquote><p><strong>File Copy 1024 bufsize 2000 maxblocks        901513.4 KBps  (30.0 s, 2 samples)</strong><br><strong>File Copy 256 bufsize 500 maxblocks          244787.5 KBps  (30.0 s, 2 samples)</strong><br><strong>File Copy 4096 bufsize 8000 maxblocks       2477326.5 KBps  (30.0 s, 2 samples)</strong></p><blockquote><p>File copy<br>测试从一个文件向另外一个文件传输数据的速率。每次测试使用不同大小的缓冲区。这一针对文件 read、write、copy 操作的测试统计规定时间（默认是 10s）内的文件 read、write、copy 操作次数。</p></blockquote><p><strong>Pipe Throughput                             1537462.9 lps   (10.0 s, 7 samples)</strong></p><blockquote><p>Pipe Throughput<br>管道（pipe）是进程间交流的最简单方式，这里的 Pipe throughtput 指的是一秒钟内一个进程可以向一个管道写 512 字节数据然后再读回的次数。需要注意的是，pipe throughtput 在实际编程中没有对应的真实存在</p></blockquote><p><strong>Pipe-based Context Switching                 305561.4 lps   (10.0 s, 7 samples)</strong></p><blockquote><p>Pipe-based Context Switching<br>这个测试两个进程（每秒钟）通过一个管道交换一个不断增长的整数的次数。这一点很向现实编程中的一些应用，这个测试程序首先创建一个子进程，再和这个子进程进行双向的管道传输。</p></blockquote><p><strong>Process Creation                              11077.6 lps   (30.0 s, 2 samples)</strong></p><blockquote><p>Process Creation<br>测试每秒钟一个进程可以创建子进程然后收回子进程的次数（子进程一定立即退出）。process creation 的关注点是新进程进程控制块（process control block）的创建和内存分配，即一针见血地关注内存带宽。一般说来，这个测试被用于对操作系统进程创建这一系统调用的不同实现的比较。</p></blockquote><p><strong>Shell Scripts (1 concurrent)                   5052.8 lpm   (60.0 s, 2 samples)</strong><br><strong>Shell Scripts (8 concurrent)                    673.0 lpm   (60.0 s, 2 samples)</strong></p><blockquote><p>Shell Scripts<br>测试一秒钟内一个进程可以并发地开始一个 shell 脚本的 n 个拷贝的次数，n 一般取值 1，2，4，8。（我在测试时取 1， 8）。这个脚本对一个数据文件进行一系列的变形操作（transformation）。</p></blockquote><p><strong>System Call Overhead                        2285994.9 lps   (10.0 s, 7 samples)</strong></p><blockquote><p>System Call Overhead<br>测试进入和离开操作系统内核的代价，即一次系统调用的代价。它利用一个反复地调用 getpid 函数的小程序达到此目的。</p></blockquote><p>System Benchmarks Index Values               BASELINE       RESULT    INDEX<br>Dhrystone 2 using register variables         116700.0   28291179.7   2424.3<br>Double-Precision Whetstone                       55.0       4275.6    777.4<br>Execl Throughput                                 43.0       3557.4    827.3<br>File Copy 1024 bufsize 2000 maxblocks          3960.0     901513.4   2276.5<br>File Copy 256 bufsize 500 maxblocks            1655.0     244787.5   1479.1<br>File Copy 4096 bufsize 8000 maxblocks          5800.0    2477326.5   4271.3<br>Pipe Throughput                               12440.0    1537462.9   1235.9<br>Pipe-based Context Switching                   4000.0     305561.4    763.9<br>Process Creation                                126.0      11077.6    879.2<br>Shell Scripts (1 concurrent)                     42.4       5052.8   1191.7<br>Shell Scripts (8 concurrent)                      6.0        673.0   1121.6<br>System Call Overhead                          15000.0    2285994.9   1524.0</p><p>System Benchmarks Index Score                                        1353.8</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ol><li><a href="https://cloud.baidu.com" title="百度云" target="_blank" rel="noopener">百度云</a></li><li><a href="https://teddysun.com/245.html" title="Linux性能测试UnixBench一键脚本" target="_blank" rel="noopener">Linux性能测试UnixBench一键脚本</a></li></ol>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
            <tag> baidu </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cd文件夹还需要一个x执行权限</title>
      <link href="/2018-03-17/cd%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%98%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAx%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90/"/>
      <url>/2018-03-17/cd%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%98%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAx%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>X：普通用户权限下，若想要cd进入一个目录，则需要该用户具有对该目录的可执行权限x。<br>R：显示该目录下的文件，则需要r读权限。<br>W：对其目录下文件进行增删等操作时需要的是w写权限<br>超级用户root权限下，不需要任何权限，即可直接对用户目录进行操作。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果把文件夹比作一个完全黑暗的房间来说，那么：<br>一个文件夹的X权限就好像一把房间的锁一样，如果有一个文件夹的X权限，那么就是有这个文件夹进门的权限，但是里面有啥，你完全不知道。就好像进门后，一切都是黑暗的。R权限就好像房间里的灯的开关，如果有了一个文件夹R权限，那么就好像开灯了一样，你就可以知道房间里的东西。W权限就是说，你可以对房间进行装饰，改造，做隔断，改名字。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ol><li><a href="http://blog.csdn.net/jenaeli/article/details/68212928" title="cd一个目录需要什么权限？显示其中文件呢？" target="_blank" rel="noopener">cd一个目录需要什么权限？显示其中文件呢？</a></li></ol>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dir </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql索引以及优化</title>
      <link href="/2018-03-04/mysql%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2018-03-04/mysql%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>数据库优化，在软件初期可能影响没那么明显，但是当数据库的规模扩展到一定的规模，则每个程序员必须要了解一定的优化策略，不然mysql的查询语句都不知道怎么写才合适。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="慢查询优化基本步骤-1"><a href="#慢查询优化基本步骤-1" class="headerlink" title="慢查询优化基本步骤[1]"></a>慢查询优化基本步骤<sup>[1]</sup></h3><ol><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li>where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li><li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li><li>order by limit 形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建索引的几大原则</li><li>观察结果，不符合预期继续从0分析<br>备注：<br>1，如何发现慢查询SQL，可以通过设置<code>--log-slow-queries</code>参数进行慢查询SQL 语句日志记录<br>2，show profile 用于分析SQL 记录，分析线程中的每个状态和消耗时间，trace 分析MYSQL优化器选择执行计划。</li></ol><h3 id="索引（Index）"><a href="#索引（Index）" class="headerlink" title="索引（Index）"></a>索引（Index）</h3><p>索引有个最左前缀匹配匹配原则，所有的规则都有它底层原因。由于通常说的索引是B-Tree索引<sup>[2]</sup>,树状的，搜索需要从根节点出发，上层节点对应靠左的值，搜索需要从根节点出发，所以有最左原则。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ol><li><a href="https://tech.meituan.com/mysql-index.html" title="MySQL索引原理及慢查询优化" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" title="MySQL索引背后的数据结构及算法原理" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></li></ol>]]></content>
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
            <tag> optimize </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单链表检测是否有环</title>
      <link href="/2018-02-06/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"/>
      <url>/2018-02-06/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>单链表是否有环的问题，并且如何找到环的出口？</p><h2 id="一个比悲伤还悲伤的故事："><a href="#一个比悲伤还悲伤的故事：" class="headerlink" title="一个比悲伤还悲伤的故事："></a>一个比悲伤还悲伤的故事：</h2><p>可以用一个比较形象的单恋情况来表达：<br>大学里，一个男生A要追女生S，男生A经过几个月的追踪记录，统计分析，发现女生S在每周三晚上8点半会从男生寝室门口的岔路口X，然后到北体操场跑步。男生A周三5点吃完饭，换好衣服就在岔路口X等，蹲点等，终于等了三个小时后发现女生S出现，开始往北体育场跑去。男生A也从男生寝室门口的岔路口X开始跑步，但是由于不想给女生S造成尾随的感觉，所以男生A以女生S两倍的速度开始往北体跑去，希望能在跑圈的时候造成偶遇的错觉。因为岔路口X到北体只有一条路，并且他坚信女生S一定会去跑圈。在男生跑到第29.5圈的时候，终于遇到了女生S，但是这时候，男生A跑圈过度累死了，同时情敌B出现，情敌B也从岔路口X往北体去跑圈。但是情敌B的速度和女生S是一样的。造化弄人，情敌B与女生S正好在北体的入口相遇。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1，如果两个人跑圈，只要速度不同，两个人必然会相遇（检测环）<br>2，如果两个人跑圈，如果相遇了，那么跑得快的那个人必然比跑得慢的人多跑了整数圈（找入口，A的速度是S的整数倍）<br>3，追女孩子，别跑太快（看缘分）</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ol><li><a href="http://blog.csdn.net/cyuyanenen/article/details/51712420" title="判断一个单链表是否有环，若有，找出环的入口节点" target="_blank" rel="noopener">判断一个单链表是否有环，若有，找出环的入口节点</a></li></ol>]]></content>
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Process与Thread与Coroutine</title>
      <link href="/2018-02-04/Process%E4%B8%8EThread%E4%B8%8ECoroutine/"/>
      <url>/2018-02-04/Process%E4%B8%8EThread%E4%B8%8ECoroutine/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>进程，线程，是一个程序员经常遇到的，也是必须好好理解的东西，协程是nova组件中用得比较多的概念，也要好好理解下。确实，自己还很差，不懂还有很多，路漫漫其修远兮，吾将上下而求索。</p><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程中调用的指令和本地变量。<br>第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。<sup>[2]</sup></p><h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>线程是进程的一个实体，称之为“进程的小弟”，是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源（比如进程需要的独立内存空间）,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。<sup>[7]</sup></p><h3 id="协程："><a href="#协程：" class="headerlink" title="协程："></a>协程：</h3><p>一种用户控制的轻量级线程（子函数）。之所以有协程，是因为即使线程比进程的切换开销更小，但是依旧线程切换有开销，并且线程执行的顺序不可控，还要用加锁等方式来控制线程之间的资源使用。协程是一种更加轻量级别的用户态线程，调度由用户控制，不用担心线程之间的竞争问题，切换开销非常小。</p><table><thead><tr><th>名</th><th>切换开销</th><th>调度负责</th><th>地址空间</th><th>缺点</th></tr></thead><tbody><tr><td>进程</td><td>大</td><td>系统</td><td>独占</td><td>开销大等等</td></tr><tr><td>线程</td><td>小</td><td>系统</td><td>共享进程的地址空间</td><td>由系统调度抢占cpu</td></tr><tr><td>协程</td><td>很小</td><td>用户</td><td>X</td><td>管理调度复杂</td></tr></tbody></table><h3 id="多进程实现的简易shell（来自UNIX高级环境编程）"><a href="#多进程实现的简易shell（来自UNIX高级环境编程）" class="headerlink" title="多进程实现的简易shell（来自UNIX高级环境编程）"></a>多进程实现的简易shell（来自UNIX高级环境编程）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span><span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">/* our signal-catching function */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span>buf[MAXLINE];<span class="comment">/* from apue.h */</span></span><br><span class="line"><span class="keyword">pid_t</span>pid;</span><br><span class="line"><span class="keyword">int</span>status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">err_sys(<span class="string">"signal error"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%% "</span>);<span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line"><span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;<span class="comment">/* 进程复制 */</span></span><br><span class="line">err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;<span class="comment">/* 子进程执行输入的命令 */</span></span><br><span class="line">execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">err_ret(<span class="string">"couldn't execute: %s"</span>, buf);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* parent */</span></span><br><span class="line"><span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>) <span class="comment">/*父进程等待子进程的完成 */</span></span><br><span class="line">err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sig_int(<span class="keyword">int</span> signo)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"interrupt\n%% "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h3><ol><li><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" title="进程与线程的一个简单解释" target="_blank" rel="noopener">进程与线程的一个简单解释</a></li><li><a href="https://www.jianshu.com/p/2b993a4b913e" title="进程,线程 -&gt;iOS 多线程 runloop" target="_blank" rel="noopener">进程,线程 -&gt;iOS 多线程 runloop</a></li><li><a href="https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" title="Python中关键字yield有什么作用?" target="_blank" rel="noopener">Python中关键字yield有什么作用?</a></li><li><a href="http://www.dabeaz.com/coroutines/" title="A Curious Course on Coroutines and Concurrency" target="_blank" rel="noopener">A Curious Course on Coroutines and Concurrency</a></li><li><a href="http://greenlet.readthedocs.io/en/latest/" title="greenlet: Lightweight concurrent programming" target="_blank" rel="noopener">greenlet: Lightweight concurrent programming</a></li><li><a href="https://www.cnblogs.com/Security-Darren/p/4170031.html" title="Python——eventlet" target="_blank" rel="noopener">Python——eventlet</a></li><li><a href="http://www.cnblogs.com/lxmhhy/p/6041001.html" title="进程和线程、协程之间的区别" target="_blank" rel="noopener">进程和线程、协程之间的区别</a></li></ol>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> Process </tag>
            
            <tag> Coroutine </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ansible主机组的定义方式</title>
      <link href="/2018-01-31/ansible%E4%B8%BB%E6%9C%BA%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F/"/>
      <url>/2018-01-31/ansible%E4%B8%BB%E6%9C%BA%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>前几天的有同事修改代码，发现其将ansible主机组分为 intstalled_HA+LB，installed_HA，installed_LB等等。一看就不是简洁的方式，其实ansible有对主机组进行类似集合一样的操作符，所以最好将主机分为最小特征颗粒组，然后用集合操作符号来进行合并与拆分，简洁又高效。</p><h2 id="几种ansible主机组的定义方式："><a href="#几种ansible主机组的定义方式：" class="headerlink" title="几种ansible主机组的定义方式："></a>几种ansible主机组的定义方式：</h2><h3 id="定义主机"><a href="#定义主机" class="headerlink" title="定义主机"></a>定义主机</h3><ul><li><code>all</code> , <code>*</code> : 定义的所有主机</li><li><code>192.168.1.*</code> :  用ip来选择主机，其中<code>*</code>类似正则表达式</li><li><code>ws[00-99].example.com</code>: 用域名方式来定义多个主机</li></ul><h3 id="主机集合操作"><a href="#主机集合操作" class="headerlink" title="主机集合操作"></a>主机集合操作</h3><ul><li><code>gr1:gr2</code> :并集，主机组gr1 并上 主机组gr2，并且会自动去重主机。</li><li><code>gr1:&amp;gr2</code>:交集，同时在两个主机集合gr1与gr2中的主机</li><li><code>gr1:!gr2</code>:差集，在gr1中主机但是不能在gr2中主机组</li></ul><h3 id="复杂集合操作"><a href="#复杂集合操作" class="headerlink" title="复杂集合操作"></a>复杂集合操作</h3><p>利用以上的一些集合操作，可以实现多次过滤，找到相对比较复杂的主机,如下：<br><code>*.example.com:frontend:&amp;US:!prod</code></p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ul><li><p><a href="https://fale.io/blog/2017/03/01/ansible-inventories/" title="Ansible Inventories" target="_blank" rel="noopener">Ansible Inventories</a></p></li><li><p><a href="http://docs.ansible.com/ansible/latest/intro_inventory.html" title="ansible.docs.Inventory" target="_blank" rel="noopener">ansible.docs.Inventory</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一只青蛙引发的思考</title>
      <link href="/2018-01-25/%E4%B8%80%E5%8F%AA%E9%9D%92%E8%9B%99%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018-01-25/%E4%B8%80%E5%8F%AA%E9%9D%92%E8%9B%99%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>最近“青蛙旅行”很火，即使它是一款日文游戏，但是依然很火。给我的感觉就好像，即使网易云音乐还是没版权，依然还有很多人用网易云音乐一样。</p><p>做app细节真的很重要，“青蛙旅行”是一款不花钱也能玩的游戏，它也打广告，但是它不是像一些国内的软件一样打广告。来讲下国内app打广告的形式吧。</p><p>进入刷屏式：比如点开一款app，一个动态或者非动态的全屏广告出现，2s后右下角可以点击跳过<br><a href="https://thumbnail0.baidupcs.com/thumbnail/995cb5ab89b308133e286d9f768259a3?fid=1041026105-250528-629143148958092&amp;time=1516885200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-kzhsl3EUh5m%2B6oPhuXM5VFquAqE%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=577172803691333864&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" title="进入刷屏式" target="_blank" rel="noopener"><img src="https://thumbnail0.baidupcs.com/thumbnail/995cb5ab89b308133e286d9f768259a3?fid=1041026105-250528-629143148958092&amp;time=1516885200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-kzhsl3EUh5m%2B6oPhuXM5VFquAqE%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=577172803691333864&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="进入刷屏式" title="进入刷屏式"></a></p><p>浏览时潜伏：用户浏览一些信息的时候，打扮成正常国军的样貌，希望能博人眼球。<br><a href="https://thumbnail0.baidupcs.com/thumbnail/d159054e7de78463a0af19c2f6f6ef05?fid=1041026105-250528-326433758532346&amp;time=1516885200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-VC3uaGlsAikFwdM6ArQ7wFWd05s%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=577212802151751981&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" title="浏览时潜伏" target="_blank" rel="noopener"><img src="https://thumbnail0.baidupcs.com/thumbnail/d159054e7de78463a0af19c2f6f6ef05?fid=1041026105-250528-326433758532346&amp;time=1516885200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-VC3uaGlsAikFwdM6ArQ7wFWd05s%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=577212802151751981&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="浏览时潜伏" title="浏览时潜伏"></a></p><p>这些app，你们真的在认真打广告吗？</p><p>“青蛙旅行”也是一款打广告的游戏，但是它打得很有特色，特色就是，它打广告打在一个你必须会去看的地方，那个地方也要收信，收礼物。家门口的邮箱里面。这个邮箱有多个功能，有邮寄来的礼物，也有一些信件。当你点开邮箱的时候，有可能会弹出广告，也有可能会收到礼物，那么如果是用户，你点不点呢？<br><a href="https://thumbnail0.baidupcs.com/thumbnail/d9abdffd3644f6641874749173911a0e?fid=1041026105-250528-7126728951764&amp;time=1516885200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-dUiP6TpZPh9QITJDcryHFYds%2F0Y%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=577157767895844807&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" title="家门口" target="_blank" rel="noopener"><img src="https://thumbnail0.baidupcs.com/thumbnail/d9abdffd3644f6641874749173911a0e?fid=1041026105-250528-7126728951764&amp;time=1516885200&amp;rt=sh&amp;sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-dUiP6TpZPh9QITJDcryHFYds%2F0Y%3D&amp;expires=8h&amp;chkv=0&amp;chkbd=0&amp;chkpc=&amp;dp-logid=577157767895844807&amp;dp-callid=0&amp;size=c710_u400&amp;quality=100&amp;vuk=-&amp;ft=video" alt="家门口" title="家门口"></a></p><p>打广告也要用心打，换种形式吧，既不影响用户体验，也能给广告商交差。比如每天摇奖，可以摇到奖品也可以摇到广告牌，广告牌有对应的收藏价值。因为广告是有时效性的，这个广告打过了，以后就不会再打了，所以广告就好像炉石的卡背一样，做成可以收藏的一个页面，当连续收藏到一定数量后，可以兑换礼物。当然不可否认，广告也有动人的广告，许多广告拍成的微电影，真的可以用来收藏，以后也会回头看。</p>]]></content>
      
      <categories>
          
          <category> 小读小想小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几百万条的定时任务用什么数据结构来存储的问题</title>
      <link href="/2018-01-23/%E5%87%A0%E7%99%BE%E4%B8%87%E6%9D%A1%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AD%98%E5%82%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2018-01-23/%E5%87%A0%E7%99%BE%E4%B8%87%E6%9D%A1%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9D%A5%E5%AD%98%E5%82%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>一个特别厉害大佬的问题：<br>如果有几百万个定时任务，让你用一种数据结构来存储查询，那么你会用什么样的数据结构与算法？</p><p>一个刚入门就写python的懵逼青年，2年代码没见过数据结构，只用过list,set,dict,str，排序用python一个sort就ok了。看来对于线性表，链表，栈，队列，一群树，还有图还有排序查找算法是要好好再研究研究，跪在门口的感觉有没有。</p><p>好了，总结就是，我又要开始学数据结构与算法了，看来平时虽然不用的东西，但是如果是基础，就像abc一样，还是要懂的。</p><p>标题问题暂时留着，到时候自然就知道了。<br>2018.1.23:mysql btree索引用的树结构，那么在现有的知识条件下，我可以猜测其为树的数据结构来存储几百万条的时间记录，算法是否可以用二分查找。<br>2018.1.26: 如果一个人连数据结构+算法都没学过，那么写出来的程序必然无法有良好的用户体验。采用平衡树来存储几百万条的定时任务中的时间，因为时间是一个非随机的key，它是一个等长的字段。平衡树不会有二叉树退化成链表的情况，导致复杂度从O（h树高）增大为 O(n节点数)。</p><p><a href="https://images2015.cnblogs.com/blog/760432/201610/760432-20161005131748739-688884364.png" title="常用数据结构选择流程图，引用自【3】" target="_blank" rel="noopener"><img src="https://images2015.cnblogs.com/blog/760432/201610/760432-20161005131748739-688884364.png" alt="常用数据结构选择流程图，引用自【3】" title="常用数据结构选择流程图，引用自【3】"></a></p><p>20180128： 算法可视化： <a href="https://visualgo.net/en" title="visualgo" target="_blank" rel="noopener">visualgo</a><br>20180131： 有一种东西叫数据库，几百万条的时间记录，存数据库吧。数据库索引有多种，btree，hash，都可以。ps算法导论是数学书吧<br>20180207: Hashed and Hierarchical Timing Wheels</p><p>相关阅读：</p><ol><li><a href="https://www.jianshu.com/p/230e6fde9c75" title="常见数据结构与算法整理总结（上）" target="_blank" rel="noopener">常见数据结构与算法整理总结（上）</a></li><li><a href="https://www.jianshu.com/p/42f81846c0fb" title="常见数据结构与算法整理总结（下）" target="_blank" rel="noopener">常见数据结构与算法整理总结（下）</a></li><li><a href="https://www.cnblogs.com/lz3018/p/5932198.html" title="常见数据结构应用场景" target="_blank" rel="noopener">常见数据结构应用场景</a></li><li><a href="https://visualgo.net/en" title="visualgo" target="_blank" rel="noopener">visualgo</a></li><li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2008/" title="Introduction to Algorithms" target="_blank" rel="noopener">Introduction to Algorithms</a></li></ol>]]></content>
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataStructure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>time.sleep后的time.clock</title>
      <link href="/2018-01-19/time-sleep%E5%90%8E%E7%9A%84time-clock/"/>
      <url>/2018-01-19/time-sleep%E5%90%8E%E7%9A%84time-clock/</url>
      <content type="html"><![CDATA[<h1 id="time-clock-与-time-sleep"><a href="#time-clock-与-time-sleep" class="headerlink" title="time clock 与 time sleep"></a>time clock 与 time sleep</h1><p>最近又遇到一个time模块的问题，先看如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">time_count</span><span class="params">(out_time)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_deco</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            start_t = time.clock()</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">            end_t = time.clock()</span><br><span class="line">            cost_t = end_t - start_t</span><br><span class="line">            <span class="keyword">if</span> cost_t &gt; out_time:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"func %s run %s s out limted time %s  s !"</span> \</span><br><span class="line">                    % (func.__name__, cost_t, out_time)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"func %s run %s s successfully !"</span> \</span><br><span class="line">                    % (func.__name__, cost_t)</span><br><span class="line">        <span class="keyword">return</span> _deco</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"><span class="meta">@time_count(1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="keyword">for</span> i  <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@time_count(1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo2</span><span class="params">()</span>:</span></span><br><span class="line">     time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line">foo2()</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$: func foo run <span class="number">3.000463</span> s out limted time <span class="number">1</span> s !</span><br><span class="line">$: func foo2 run <span class="number">7.39999999997e-05</span> s successfully !</span><br></pre></td></tr></table></figure></p><p>foo2中time.sleep(2)居然没有生效，小小百度了下：<br>答案：<br>中文：<br>time.clock()是返回CPU时间或线程自启动以来或从第一次调用clock()到现在的时间。<br>一般来讲测试程序耗时这个是最准确的<br>知道这个是做什么的就应该知道了它的初始值确实是0，<br>当运行程序开始开始计数为0，一直记录程序运行的cpu执行时间。<br>所以，一般来讲，如果你time.clock()之前没有执行什么耗费CPU时间的程序，那么time.clock()就为0。<br>英文：<br>On Unix, return the current processor time as a floating point number expressed in seconds. The precision, and in fact the very definition of the meaning of “processor time”, depends on that of the C function of the same name, but in any case, this is the function to use for benchmarking Python or timing algorithms.</p><p>On Windows, this function returns wall-clock seconds elapsed since the first call to this function, as a floating point number, based on the Win32 function QueryPerformanceCounter. The resolution is typically better than one microsecond.</p><p><a href="http://download.csdn.net/download/E_wsq/2397508" title="Chronograph Atomic Time Clock 6.40(校时原子钟的时间工具)英文绿色特别版" target="_blank" rel="noopener">Chronograph Atomic Time Clock 6.40(校时原子钟的时间工具)英文绿色特别版</a></p><p>也就是说time.clock计算的是cpu时间，time.sleep过程中cpu没有做任何计算，所以time.clock根本不会变化。所以还是改成<code>time.time(2)</code>比较合理。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ul><li><p><a href="http://blog.csdn.net/csupengu/article/details/38121973" title="python time.clock()不变的原因" target="_blank" rel="noopener">python time.clock()不变的原因</a></p></li><li><p><a href="https://stackoverflow.com/questions/85451/python-time-clock-vs-time-time-accuracy" title="Python - time.clock() vs. time.time() - accuracy?" target="_blank" rel="noopener">Python - time.clock() vs. time.time() - accuracy?</a></p></li><li><p><a href="http://jeremybai.github.io/blog/2015/06/10/time_vs_clock" title="Python中time.clock()和time.time()的区别" target="_blank" rel="noopener">Python中time.clock()和time.time()的区别</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> time </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>几篇区块链文章</title>
      <link href="/2018-01-14/%E5%87%A0%E7%AF%87%E5%8C%BA%E5%9D%97%E9%93%BE%E6%96%87%E7%AB%A0/"/>
      <url>/2018-01-14/%E5%87%A0%E7%AF%87%E5%8C%BA%E5%9D%97%E9%93%BE%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<p>最近区域链总是出现在我的视野中，找个时间查了下大概的原理。<br>真理总是掌握在少数人手中。总感觉改变世界的东西，一开始总是在一些鲜为人知的角落发芽，然后到了某个合适的时间与环境，一夜之间，如雨后春笋一般，然后人们看到后，怎么这个竹子长得这么高，这是什么竹子啊。那时候，也许就晚了。<br>区块链利用hash算法的方式，让区块不可以被改写，只能用追加的方式。就好像历史不能改写，时间只能一点一点往前走。</p><p>相关阅读：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" title="区块链入门教程" target="_blank" rel="noopener">区块链入门教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/01/cryptocurrency-tutorial.html" title="加密货币的本质" target="_blank" rel="noopener">加密货币的本质</a></li><li><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part01?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" title="揭秘比特币和区块链（一）：什么是区块链？" target="_blank" rel="noopener">揭秘比特币和区块链（一）：什么是区块链？</a></li><li><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part02?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" title="揭秘比特币和区块链（二）：什么是工作量证明？" target="_blank" rel="noopener">揭秘比特币和区块链（二）：什么是工作量证明？</a></li><li><a href="http://www.infoq.com/cn/articles/bitcoin-and-block-chain-part03?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" title="揭秘比特币和区块链（三）：比特币的私钥、公钥与地址" target="_blank" rel="noopener">揭秘比特币和区块链（三）：比特币的私钥、公钥与地址</a></li></ul>]]></content>
      
      <categories>
          
          <category> 小读小想小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain  </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>wind</title>
      <link href="/2018-01-11/wind/"/>
      <url>/2018-01-11/wind/</url>
      <content type="html"><![CDATA[<h1 id="风"><a href="#风" class="headerlink" title="风"></a>风</h1><p>高屋建瓴<br>这下面有一片树林<br>听<br>风的声音<br>没有回应<br>听<br>风的声音<br>没有树林</p>]]></content>
      
      <categories>
          
          <category> JC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nmind </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的第一台Vultr云主机</title>
      <link href="/2017-12-30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0Vultr%E4%BA%91%E4%B8%BB%E6%9C%BA/"/>
      <url>/2017-12-30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%B0Vultr%E4%BA%91%E4%B8%BB%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>作为一个云平台搬砖工，应该要有自己的一块砖，所以找砖头去吧</p><h1 id="关于选云主机"><a href="#关于选云主机" class="headerlink" title="关于选云主机"></a>关于选云主机</h1><ol><li>由于GFW的原因，电脑，手机上google，stack overflow，非常不方便。各种原因下来，还是自己找个vps吧</li><li>国内云就不考虑了，查阅了一大堆资料，感觉还是Vultr比较符合我需求，真可惜，现在新用户不送20刀了</li></ol><h1 id="搭建vps"><a href="#搭建vps" class="headerlink" title="搭建vps"></a>搭建vps</h1><p>查了很久，虽然还不是很清楚里面建立ssr+bbr的原理，关于选主机里面说的一点很赞同，Vultr主机在日本节点还有los angeles节点已经被大量占用了，因为国内的许多教程都是写的这两个节点，所以实践出真理，文章也没写到底选哪个，反正自己选个快的，具体情况具体分析。<br><a href="https://doub.bid/ss-jc42/" title="https://doub.bid/ss-jc42/" target="_blank" rel="noopener">ssr 一键脚本文章</a> + <a href="https://doub.bid/wlzy-22/" title="CentOS/Debian/Ubuntu系统 TCP-BBR 一键安装脚本" target="_blank" rel="noopener">CentOS/Debian/Ubuntu系统 TCP-BBR 一键安装脚本</a><br>个人直觉云主机还是别选人多的机房比较好，各种创建主机，各种ping，下载测试，总体来说除去以上两个机房，西雅图的机房还可以。操作系统用CentOs，一开始有个Debian的教程，上去后不习惯，最后还是切回了CentOs。<br>上述完成后，最麻烦的是ios系统App Store没有app。想注册美apple id也是缺少美信用卡。只好感谢马云爸爸，让我花十块钱买了apple id，下载potatso，大功告成。在手机连接vps的时候上网，感觉很奇妙，也许就好像同学说的潜水一样，发现了新的一个世界吧。Vultr就当元旦礼物吧，All is well.</p><h1 id="关于网络真真假假"><a href="#关于网络真真假假" class="headerlink" title="关于网络真真假假"></a>关于网络真真假假</h1><p>在网络中浏览，需要有一个自我辨别事实的意识。<br>网络作为一种信息传播的方式，充斥真实与虚假的内容。个人认为，在网络的世界里面，眼见也不一定为实，视频可以剪切，可以加特效，声音可以处理，网络中的任何信息，在浏览的时候，个人都需要有个自我辨别事实的意识，就好像学习一样，任何东西，实践才是检验真理的唯一标准。</p><p>相关阅读：</p><ul><li><p><a href="http://www.zrblog.net/" title="http://www.zrblog.net/" target="_blank" rel="noopener">赵容部落</a></p></li><li><p><a href="https://since1989.org/interserver/free-vps-hosting-hong-kong.html" title="https://since1989.org/interserver/free-vps-hosting-hong-kong.html" target="_blank" rel="noopener">真实评测：性价比最高的6家vps</a></p></li><li><p><a href="http://www.vpsdaquan.cn/vpslinodedovultrhengxiangceping.html" title="http://www.vpsdaquan.cn/vpslinodedovultrhengxiangceping.html" target="_blank" rel="noopener">VPS御三家（Linode，DO，Vultr）横向测评</a></p></li><li><p><a href="https://doub.bid/ss-jc42/" title="https://doub.bid/ss-jc42/" target="_blank" rel="noopener">ssr 一键脚本文章</a></p></li><li><p><a href="https://doub.bid/wlzy-22/" title="CentOS/Debian/Ubuntu系统 TCP-BBR 一键安装脚本" target="_blank" rel="noopener">CentOS/Debian/Ubuntu系统 TCP-BBR 一键安装脚本</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vps </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的几个小小小问题</title>
      <link href="/2017-12-17/python%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E5%B0%8F%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2017-12-17/python%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E5%B0%8F%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="python中变量值是使用时确定而非定义时"><a href="#python中变量值是使用时确定而非定义时" class="headerlink" title="python中变量值是使用时确定而非定义时"></a>python中变量值是使用时确定而非定义时</h2><p>如下例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"><span class="meta">... </span>    squares.append(<span class="keyword">lambda</span>: x**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在调用<code>squares[2]()</code>中的2可以换成0-4中的数字，返回的结果都是16。<br>原因就是python中的变量值是call的时候确定，而非定义的时候。在使用<code>squares[2]()</code>调用的时候x数值已经固定在4，所以无论什么时候调用，返回结果都是16。<br>学python过程中必须要理解变量的名字与变量的数值的关系，var-&gt;value。python的变量名字name是一个引用，python变量数值是一个内存中的值，官方英文中用object表示。python多个变量名字可以指向同一个内存空间，如果该内存空间中内容被改变，那么多个name也会同时被改变。并且python中分mutable变量与immutable变量，mutable变量就是list,dict这些，immutable变量就是数字，字符串等。上面所说的是针对mutable变量的。<br>可以从下面例子理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.append(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">10</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = [[<span class="keyword">None</span>] * <span class="number">2</span>] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">[[<span class="keyword">None</span>, <span class="keyword">None</span>], [<span class="keyword">None</span>, <span class="keyword">None</span>], [<span class="keyword">None</span>, <span class="keyword">None</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A</span><br><span class="line">[[<span class="number">5</span>, <span class="keyword">None</span>], [<span class="number">5</span>, <span class="keyword">None</span>], [<span class="number">5</span>, <span class="keyword">None</span>]]</span><br><span class="line">&gt;&gt;&gt;A = [<span class="keyword">None</span>] * <span class="number">3</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">....A[i] = [<span class="keyword">None</span>] * <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="一个可以容易改变基类的代码"><a href="#一个可以容易改变基类的代码" class="headerlink" title="一个可以容易改变基类的代码"></a>一个可以容易改变基类的代码</h2><p>类似宏定义般的代码风格，有利于后期代码维护<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BaseAlias = &lt;real base <span class="class"><span class="keyword">class</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Derived</span><span class="params">(BaseAlias)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">meth</span><span class="params">(self)</span>:</span></span><br><span class="line">        BaseAlias.meth(self)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h2 id="为何id两个变量，最后结果是一样的"><a href="#为何id两个变量，最后结果是一样的" class="headerlink" title="为何id两个变量，最后结果是一样的"></a>为何id两个变量，最后结果是一样的</h2><p>如下，为何用id去鉴定两个变量，最后返回结果是一个。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">1000</span>)</span><br><span class="line"><span class="number">13901272</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(<span class="number">2000</span>)</span><br><span class="line"><span class="number">13901272</span></span><br></pre></td></tr></table></figure></p><p>第一id返回值与变量内存地址有关，在id(1000)的时候，变量1000在内存地址是与13901272有关的一个值，但是由于1000在id(1000)后没有被引用，马上被gc回收了。之后，id(2000)在call了2000这个变量，2000这个变量马上占用之前的内存地址，最后id(2000)返回的数值与id(1000)返回数值相同也不足为奇。<br>可以用如下反证：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1000</span>; b = <span class="number">2000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">13901272</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">13891296</span></span><br></pre></td></tr></table></figure></p><h2 id="元组a-tuple-i-‘item’-虽然报错但是却生效了"><a href="#元组a-tuple-i-‘item’-虽然报错但是却生效了" class="headerlink" title="元组a_tuple[i] += [‘item’] 虽然报错但是却生效了"></a>元组a_tuple[i] += [‘item’] 虽然报错但是却生效了</h2><p>先看一段没问题的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_tuple = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_tuple[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">   ...</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>由于元组变量不可变，所以正常报错。要注意的是元组中的元素是数字，是immutable变量。<br>该代码等效于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = a_tuple[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_tuple[<span class="number">0</span>] = result</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p><p>再来看一段有问题的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_tuple = ([<span class="string">'foo'</span>], <span class="string">'bar'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_tuple[<span class="number">0</span>] += [<span class="string">'item'</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>该代码虽然也报错了，但是实际结果却发现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_tuple[<span class="number">0</span>]</span><br><span class="line">[<span class="string">'foo'</span>, <span class="string">'item'</span>]</span><br></pre></td></tr></table></figure></p><p>元组中变量0的list变化了!</p><p>用如下等效代码就可以很清楚明白这个问题了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = a_tuple[<span class="number">0</span>].__iadd__([<span class="string">'item'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_tuple[<span class="number">0</span>] = result</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure></p><p>代码中<code>a_tuple[0].__iadd__([&#39;item&#39;])</code>这段先生效，然后list已经变化了，然后immutable元组中元素0要重新赋值报错，第二步报错的时候，第一步已经成功了，所以虽然有报错，但是实际list改变已经生效了。</p><h2 id="模块循环引用问题"><a href="#模块循环引用问题" class="headerlink" title="模块循环引用问题"></a>模块循环引用问题</h2><p>两个如下模块：</p><p>foo.py:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bar <span class="keyword">import</span> bar_var</span><br><span class="line">foo_var = <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>bar.py:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> foo_var</span><br><span class="line">bar_var = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>python解释器会按照如下步骤进行：</p><ol><li>主进程import foo</li><li>全局foo生成</li><li>foo 模块编译运行</li><li>foo 模块引用bar</li><li>全局bar生成</li><li>bar 模块编译运行</li><li>在bar模块运行过程中，引用foo模块，由于有全局foo这个变量存在，所以该解释器没有进行任何import操作</li><li>最后bar.foo_var = foo.foo_var</li></ol><p>最后一步报错了，原因是因为 python解释器还没有完全import foo这模块，所以当时foo.foo_var还没定义，python解释就失败报错了。</p><p>相关阅读：</p><p><a href="https://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" title="https://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" target="_blank" rel="noopener">Python2官方的FAQ</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python中的几个小小问题</title>
      <link href="/2017-12-10/python%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2017-12-10/python%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%B0%8F%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>这周据说是水逆周，有几件事情让人心力交瘁，心情大起大落，以后应该控制下，周一面试了一个python的岗位，问了几个问题，答得7788，感觉基础还是不是很牢固，目测过的概率也不是很大。但是，每次面试都让我学习到了很多，我希望再积累一段时间，毕竟自己不懂的东西太多，总的来说，纸上得来终觉浅，绝知此事要躬行。<br><a id="more"></a></p><h2 id="python中类的属性变量如何固定？"><a href="#python中类的属性变量如何固定？" class="headerlink" title="python中类的属性变量如何固定？"></a>python中类的属性变量如何固定？</h2><p>在定义python类的时候，使用<code>__slots__</code>这个变量，可以固定python类的变量，并且如果不用<code>__slots__</code>来固定类变量，那么在创建大量实例后，内存消耗会非常严重。原因是python默认用一个dict来存储对象实例的属性，所以python作为动态语言，可以随时增加或者减少一个实例的属性。采用<code>__slots__</code>可以固定类的属性，自然创建实例后占用的空间也就少很多。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">'id'</span>, <span class="string">'caption'</span>, <span class="string">'url'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, id, caption, url)</span>:</span></span><br><span class="line">        self.id = id</span><br><span class="line">        self.caption = caption</span><br><span class="line">        self.url = url</span><br><span class="line">        self._setup()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... other methods ...</span></span><br></pre></td></tr></table></figure></p><h2 id="python类中私有变量如何定义？"><a href="#python类中私有变量如何定义？" class="headerlink" title="python类中私有变量如何定义？"></a>python类中私有变量如何定义？</h2><p>python中变量使用下划线其实很有规范，不可以乱用。</p><p>单个下划线前缀: <code>_var</code>,一种约定的私有名称的惯例，该名称表示，我是私有变量，但是如果别人一定要用，那么也是可以被使用的。<br>还有在i18n中单下划线经常被用作国际化和本地化字符串翻译查询的函数名。</p><p>双下划线前缀: <code>__var</code>, 是一种解释器实现的私有名称，在类的代码中，python会对其进行改写，如下类A中<code>__method_name</code>就在解释器中被改写成<code>_A__method_name</code>，当有一个类B对A进行继承后，该方法就会变成<code>_B__method_name</code>。可见双下划线名称是不可以乱用的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">_internal_use</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__method_name</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(A())</span><br><span class="line">[<span class="string">'_A__method_name'</span>, ..., <span class="string">'_internal_use'</span>]</span><br></pre></td></tr></table></figure></p><p>双下划线前后缀：<code>__var__</code>, 这些事python的特殊方法名称，就是官方的名称，比如类中初始化函数<code>__init__</code>, 上文中的<code>__slots__</code>, 这些都有特殊的用途，可以重写，可以重新定义，实现不同功能。</p><h2 id="python中元类的使用-ORM相关"><a href="#python中元类的使用-ORM相关" class="headerlink" title="python中元类的使用(ORM相关)"></a>python中元类的使用(ORM相关)</h2><p>其实元类就是定义类的类，type。所有类都有一个老祖宗吧，那么python就定义type就是所有类的老祖宗，那么老祖宗的老祖宗呢?就好像在根目录<code>/</code>下进行<code>cd ..</code>，上一层目录还是自己。所以type的老祖宗还是自己。</p><p>ORM使用元类来实现用户自定义各种表的列，然后采用实例来实现各种表的每一行。也就是说，表结构是一种用户自定的类，但是该实现方式是使用元类来定义，用元类实现表类，然后表中每一条记录，采用实例来实现，这样就完成ORM。</p><p>如果想实现的，廖雪峰网站有个ORM的实现，相信敲完代码，跑一下后就会理解得更加深入。</p><h2 id="Python2官方的FAQ"><a href="#Python2官方的FAQ" class="headerlink" title="Python2官方的FAQ"></a>Python2官方的FAQ</h2><p>python2官方的FAQ，里面有好多之前看到的问题，其中有一个UnbondLocalError 的bug，是面试的时候问到的，查完资料后，发现自己用python还是不够多，革命尚未成功，同事仍需搬砖。</p><p>链接：<a href="https://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" title="https://docs.python.org/2/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value" target="_blank" rel="noopener">Python2官方的FAQ</a></p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><p><a href="http://tech.oyster.com/save-ram-with-python-slots/" title="http://tech.oyster.com/save-ram-with-python-slots/ " target="_blank" rel="noopener">Saving 9 GB of RAM with Python’s <strong>slots</strong></a></p><p>译文： <a href="http://blog.jobbole.com/52420/" title="http://blog.jobbole.com/52420/" target="_blank" rel="noopener">用Python的 <strong>slots</strong> 节省9G内存</a></p><p><a href="https://shahriar.svbtle.com/underscores-in-python" title="https://shahriar.svbtle.com/underscores-in-python " target="_blank" rel="noopener">Underscores in Python</a></p><p>译文： <a href="https://segmentfault.com/a/1190000002611411" title="https://segmentfault.com/a/1190000002611411" target="_blank" rel="noopener">Python 中的下划线</a></p><p><a href="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" title="https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python " target="_blank" rel="noopener">what-is-a-metaclass-in-python “what-is-a-metaclass-in-python</a></p><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014323389656575142d0bcfeec434e9639a80d3684a7da000" title="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014323389656575142d0bcfeec434e9639a80d3684a7da000" target="_blank" rel="noopener">编写ORM(廖雪峰)</a></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hello-k8s</title>
      <link href="/2017-12-03/hello-k8s/"/>
      <url>/2017-12-03/hello-k8s/</url>
      <content type="html"><![CDATA[<p>2017年10月17日,docker宣布拥抱k8s,看来各种服务进行容器化是一股大潮流，谁跟不上就会被潮流淘汰。container对应用程序进行打包隔离，以后用户更多的应该会直接面对container而不是vm，最后到底是用户选择vm还是container，关键看需求。</p><p>这周看着k8s权威指南开始在虚拟机中用k8s管理容器。</p><h2 id="k8s中的几个概念"><a href="#k8s中的几个概念" class="headerlink" title="k8s中的几个概念"></a>k8s中的几个概念</h2><ul><li>Pod：一个或者多个相同功能的容器，个人感觉像个容器池一样</li><li>Container（容器）：k8s管理的最小单位，</li><li>Label（标签）：k8s中资源的相互调用关系采用标签来识别，采用一个高可用键值存储系统etcd实现。</li><li>Replication Controller（复制控制器）：对于多个pods进行管理，如果有一个pod挂了就会起一个新的pod。</li><li>Service（服务）：多种pod进行组合形成service，service作为一层，将pod与上层进行抽象分割，保持自身的ip:端口的稳定，并且实现LB。</li><li>Node（节点）：可以是一个服务器，也可以是一个虚拟机，负责起大量容器。有点像OpenStack中的计算节点小弟，只管控制节点需要的vm(资源)，然后和控制节点保持通讯畅通就好了。</li><li>Kubernetes Master（Kubernetes主节点）：k8s中的老大与CLI+界面联系，然后到slaves的nodes上起容器就好了。有点像OpenStack中的控制节点，管理下面的计算节点小弟弟。<a id="more"></a></li></ul><p><img src="http://dockerone.com/uploads/article/20151230/5e2bad1a25e33e2d155da81da1d3a54b.gif" alt="k8s"></p><h2 id="k8s环境部署"><a href="#k8s环境部署" class="headerlink" title="k8s环境部署"></a>k8s环境部署</h2><p>按照k8s权威指南中的一步一步进行部署redis，总体来说还算顺利，但是由于GFW的原因docker中的各种镜像太难下载了吧，还好脑子一转想到阿里云也有相关的docker镜像源<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">https://dev.aliyun.com/search.html</a>,然后将大多数镜像都下载下来了，速度飞快。其中kubelet有个pod-infrastructure是每个pod需要的镜像，每次起redis容器的时候都会有个这个镜像的容器产生，应该是k8s管理容器的一个基础容器镜像，通过这个pod-infrastructure来管理docker的container。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[root@host-172-16-1-163 y]# cat /etc/kubernetes/kubelet </span><br><span class="line">###</span><br><span class="line"># kubernetes kubelet (minion) config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The address for the info server to serve on (set to 0.0.0.0 or &quot;&quot; for all interfaces)</span><br><span class="line">KUBELET_ADDRESS=&quot;--address=127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The port for the info server to serve on</span><br><span class="line"># KUBELET_PORT=&quot;--port=10250&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># You may leave this blank to use the actual hostname</span><br><span class="line">KUBELET_HOSTNAME=&quot;--hostname-override=127.0.0.1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># location of the api-server</span><br><span class="line">KUBELET_API_SERVER=&quot;--api-servers=http://127.0.0.1:8080&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># pod infrastructure container</span><br><span class="line"># KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest&quot;</span><br><span class="line"># KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=docker.io/tianyebj/pod-infrastructure:latest&quot;</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER=&quot;--pod-infra-container-image=registry.cn-hangzhou.aliyuncs.com/architect/pod-infrastructure&quot;</span><br><span class="line"># Add your own!</span><br><span class="line">KUBELET_ARGS=&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@host-172-16-1-163 y]# cat redis-master-controller.yaml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: redis-master</span><br><span class="line">  labels:</span><br><span class="line">    name: redis-master</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    name: redis-master</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        name: redis-master</span><br><span class="line">    spec: </span><br><span class="line">      containers:</span><br><span class="line">      - name: master </span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/lonntec/kubeguide-redis-master</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 6379</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>1.k8s本身如何做ha？<br>接触较多的是pacemaker+corosync实现ha，其中如果有相关服务存储采用本地盘的化就用drbd实现同步。<br>2，k8s作为一个服务，那么讲道理也可以直接跑在docker中，找个时间试试。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ul><li><p><a href="http://omerio.com/2015/12/18/learn-the-kubernetes-key-concepts-in-10-minutes/" title="http://omerio.com/2015/12/18/learn-the-kubernetes-key-concepts-in-10-minutes/" target="_blank" rel="noopener">Learn the Kubernetes Key Concepts in 10 Minutes</a></p></li><li><p><a href="http://blog.csdn.net/levy_cui/article/details/70215627" title="http://blog.csdn.net/levy_cui/article/details/70215627" target="_blank" rel="noopener">Kubernetes系列01：Kubernetes入门</a></p></li><li><p><a href="http://www.cnblogs.com/zhenyuyaodidiao/p/6500950.html" title="http://www.cnblogs.com/zhenyuyaodidiao/p/6500950.html" target="_blank" rel="noopener">为Kubernetes集群部署本地镜像仓库</a></p></li><li><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-kubernetes-developer-guide/index.html" title="https://www.ibm.com/developerworks/cn/opensource/os-kubernetes-developer-guide/index.html" target="_blank" rel="noopener">Kubernetes 开发指南</a></p></li><li><p><a href="https://kubernetes.io/docs/getting-started-guides/centos/centos_manual_config/" title="CentOS 部署k8s 英文原文" target="_blank" rel="noopener">CentOS 部署k8s 英文原文</a></p></li><li><a href="https://www.kubernetes.org.cn/doc-16" title="CentOS部署Kubernetes集群" target="_blank" rel="noopener">CentOS部署Kubernetes集群</a></li></ul>]]></content>
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker中的Namespace</title>
      <link href="/2017-11-26/docker%E4%B8%AD%E7%9A%84Namespace/"/>
      <url>/2017-11-26/docker%E4%B8%AD%E7%9A%84Namespace/</url>
      <content type="html"><![CDATA[<p>最近开始研究docker与k8s部署相关的知识。k8s是容器编排工具，docker又是主流容器，其中docker底层采用了NAMESACE来做资源隔离，用CGROUP来控制资源的控制，还有docker是用GO语言写的，看来要学习的地方还有很多。</p><p>NAMESPACE主要是docker用来做容器的资源隔离。对系统的主机名，域名，IPC，PID，网络，文件系统，用户与用户组做资源隔离。与fork一个进程类似，但是其中涉及的方面更加细，更加广。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><ul><li><p><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" title="http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="noopener">Docker背后的内核知识——Namespace资源隔离</a></p></li><li><p><a href="https://docs.docker.com" title="https://docs.docker.com" target="_blank" rel="noopener">docker 官方文档</a></p></li><li><p><a href="https://lwn.net/Articles/531114/" title="Namespaces in operation" target="_blank" rel="noopener">Namespaces in operation</a></p></li></ul>]]></content>
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> namespace </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个时间跳变导致的多线程卡死在time.sleep中的问题</title>
      <link href="/2017-11-20/%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E8%B7%B3%E5%8F%98%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%A1%E6%AD%BB%E5%9C%A8time-sleep%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017-11-20/%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E8%B7%B3%E5%8F%98%E5%AF%BC%E8%87%B4%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8D%A1%E6%AD%BB%E5%9C%A8time-sleep%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近在公司遇到一个多线程卡死的问题：在对多个主机进行多线程操作的时候，主机的时钟进行ntp同步后进行了往后跳变，导致在线程进入time.sleep的时候卡死的问题。<br><a id="more"></a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>主要问题在于，在用多线程进行time.sleep切换的时候，社区的oslo service 采用了wall clock，导致线程进行time sleep切换后，无法等待至end time。比如 end_time = start_time + sleep_time，比如说start_time =7:00，在进入sleep time（10s） 后，start_time由于主机的时钟同步，导致start_time时光回溯，start_time=6:00。此刻，多线程一直卡死在time.sleep(10)的状态下，一直等一个小时10秒后，才能进行sleep后的操作。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法:"></a>解决办法:</h1><p>1,采用libc中time sleep，该sleep是monotonic clock，不会产生时光回溯的问题。但是该时钟在实际使用中无法实现time.sleep的多线程切换的功能。所以我进行了小小的改动，虽然不完善，后续会研究更加完美的方法。<br>2，暂时办法：用libc.time.sleep（1）然后紧跟time.sleep(0.0005)<br>第一个sleep可以进行正常的延迟，第二个超短时间的延迟用于线程的切换。</p><h2 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h2><p><a href="http://i2cbus.blog.51cto.com/9231371/1534933" title="http://i2cbus.blog.51cto.com/9231371/1534933" target="_blank" rel="noopener">Python 官方代码threading模块的一个死锁的bug</a> </p><p><a href="https://stackoverflow.com/questions/1205722/how-do-i-get-monotonic-time-durations-in-python" target="_blank" rel="noopener">how-do-i-get-monotonic-time-durations-in-python</a></p><ul><li>OpenStack社区上的相关bug<br>Relate issue: <a href="https://bugs.launchpad.net/mos/+bug/1642103" target="_blank" rel="noopener">https://bugs.launchpad.net/mos/+bug/1642103</a> services hang when time is jumping forward and backward<br>Related patch that fixes the issue for oslo:<br><a href="https://review.openstack.org/#/c/190372/" target="_blank" rel="noopener">https://review.openstack.org/#/c/190372/</a><br>Same topic:<br><a href="https://review.openstack.org/#/c/286838/" target="_blank" rel="noopener">https://review.openstack.org/#/c/286838/</a><br><a href="https://review.openstack.org/#/c/434327" target="_blank" rel="noopener">https://review.openstack.org/#/c/434327</a></li></ul>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> time </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MYSQL-中的join-语句.md</title>
      <link href="/2017-11-06/MYSQL-%E4%B8%AD%E7%9A%84join-%E8%AF%AD%E5%8F%A5-md/"/>
      <url>/2017-11-06/MYSQL-%E4%B8%AD%E7%9A%84join-%E8%AF%AD%E5%8F%A5-md/</url>
      <content type="html"><![CDATA[<p>1, left join 可以将两个表进行合并，左表的数据完全保留，右表的数据在on条件符合的情况下进行筛选后保留。<br>select P.FirstName, P.LastName, A.City, A.State from Person as P LEFT JOIN Address as A on P.PersonId = A.PersonID<br>select 左右表数据 from 左表 as 简名 LEFT JOIN 右表 as 简名 on 过滤条件<br> 同理，right join 可以将右表所有数据显示，将左表过滤显示。<br><a id="more"></a></p><p>如下文章用集合来表示，join的数据结构。<br><a href="http://www.cnblogs.com/sunjie9606/p/4167190.html" target="_blank" rel="noopener">http://www.cnblogs.com/sunjie9606/p/4167190.html</a></p><p>inner join 表示交集，<br>full join 表示合集<br>left join 表示左全集附加右过滤条件<br>right join 表示右<br>outer join 包括full left right join</p><p>cross join表示笛卡尔积，表示所有可能性的组合情况</p>]]></content>
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017-11-05/hello-world/"/>
      <url>/2017-11-05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> JC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
